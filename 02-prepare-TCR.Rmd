---
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r setup-TCR, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.width=10, fig.height=7) 
library(tidyverse) 
library(patchwork)  # for combining figures
library(gplots)     # for heatmap.2
library(ggtree)    # for trees
library(doParallel)
library(ape)   # for as.phylo
```

# Processing the raw TCR data
### Parsing and processing the TCR Data

The following chunk serves two purposes: reading in the TCR data, and calculating the JSD correlations based on the TCR profiles.  This takes a while, so the results are saved in an object called `tcr_objects.Rdata`. If this object is not found, it will create it. 

```{R}
tcr_objects_path <- "tcr_objects.Rdata"
if(!file.exists(tcr_objects_path)){
  tcr_raw_output <- file.path("data/TCR", "tcr_unified.csv")
  tcr_raw <- read.csv(tcr_raw_output)
  these_samples <-  unique(tcr_raw$sample_name)
  #tcr_raw <- tcr_raw %>% filter(sample_name %in%  these_samples[1:50])
  tcr_raw_filt <-  tcr_raw %>% 
    filter(frame_type == "In") %>% 
    select(sample_name, rearrangement, amino_acid, productive_frequency) %>%
    filter(!is.na(productive_frequency))
  nrow(tcr_raw_filt)
  dt_tcr_w <- tcr_raw_filt %>% 
    data.table::as.data.table() %>% 
    data.table::dcast(sample_name~rearrangement, fill = 0, value.var="productive_frequency" ) %>%
    column_to_rownames("sample_name") %>% 
    data.matrix()
  
  tmp <- rep(1, n_distinct(tcr_raw_filt$sample_name))
  names(tmp) <- rownames(dt_tcr_w)
  all.equal(tmp, rowSums(dt_tcr_w))
  
  dt_tcr_w_aa <- tcr_raw_filt %>% 
    data.table::as.data.table() %>% 
    data.table::dcast(sample_name~amino_acid, fill = 0, value.var="productive_frequency", fun.aggregate = sum ) %>%
    column_to_rownames("sample_name") %>% 
    data.matrix()
  
  #df of all sample combinations
  sample_combinations <- expand.grid(sample1=rownames(dt_tcr_w), sample2=rownames(dt_tcr_w)) %>% as_tibble() %>% 
    mutate(sample1=as.character(sample1), sample2=as.character(sample2))

  
  # calculate 
  system.time({tcr_raw_w_jsd  <- philentropy::JSD(dt_tcr_w, est.prob = "empirical" )})
  ##    user   system  elapsed 
  ## 2962.610  227.388 3250.489 
  system.time({tcr_raw_w_jsd_aa  <- philentropy::JSD(dt_tcr_w_aa, est.prob = "empirical" )})
  
  # system.time({par_jsd <- for (i=0:(nrow(sample_combinations)/50), .combine=rbind) %dopar% {
  #    philentropy::JSD(dt_tcr_w[c(sample_combinations$sample1[(i*50):((i*50)+50)], sample_combinations$sample2[(i*50):((i*50)+50)]),], est.prob = "empirical")
  #   }
  # })
  # system.time({par_jsd <- foreach (i=0:(nrow(sample_combinations)/50), .combine=rbind) %dopar% {
  #    philentropy::JSD(dt_tcr_w[sample_combinations$sample1[(i*50):((i*50)+50)],], est.prob = "empirical")
  #   }
  # })

  # colnames(par_jsd) <- "jsd_new"
  # rownames(par_jsd) <- NULL  
  
  
  registerDoParallel(6)
  par_morisita <- foreach (i=1:nrow(sample_combinations), .combine=rbind) %dopar% {
    horn_morisita(dt_tcr_w[sample_combinations$sample1[i], ], dt_tcr_w[sample_combinations$sample2[i], ]) 
  }
  colnames(par_morisita) <- "morisita"
  rownames(par_morisita) <- NULL

  par_clone_overlap <- foreach (i=1:nrow(sample_combinations), .combine=rbind) %dopar% {
    tcr_raw_filt %>% filter(sample_name %in% c(sample_combinations$sample1[i], sample_combinations$sample2[i])) %>% pivot_wider(values_from = productive_frequency, names_from = sample_name) %>% drop_na() %>% nrow()
  }
  colnames(par_clone_overlap) <- "overlapping_clones"
  rownames(par_clone_overlap) <- NULL
  
  par_aa_overlap <- foreach (i=1:nrow(sample_combinations), .combine=rbind) %dopar% {
    tcr_raw_filt %>% filter(sample_name %in% c(sample_combinations$sample1[i], sample_combinations$sample2[i])) %>%
      select(-rearrangement) %>% 
      pivot_wider(values_from = productive_frequency, names_from = sample_name, values_fn = sum) %>% drop_na() %>% nrow()
  }
  colnames(par_aa_overlap) <- "overlapping_aa"
  rownames(par_aa_overlap) <- NULL

  stopImplicitCluster()
  sample_combinations <- cbind(sample_combinations, par_morisita,par_clone_overlap, par_aa_overlap )
  
  
  # the `colnames<-`(rownames(tcr_raw_w_jsd))  fixes the messed up column punctuation
  tcr_corrs <- pivot_longer(data.frame(tcr_raw_w_jsd) %>% `colnames<-`(rownames(tcr_raw_w_jsd)) %>% rownames_to_column("sample1"), cols=-sample1 , names_to = "sample2", values_to = "JSD" ) %>% 
    full_join(pivot_longer(data.frame(tcr_raw_w_jsd_aa)  %>% `colnames<-`(rownames(tcr_raw_w_jsd)) %>% rownames_to_column("sample1"), cols=-sample1 , names_to = "sample2", values_to = "JSD_aa" ), by=c("sample1", "sample2")) %>% 
    full_join(sample_combinations,  by=c("sample1", "sample2"))
    
  
  # verify against original calculations if desired  
  if (FALSE){
    orig_jsd <- read.csv("JSD_MI_all.csv") %>% rename(JSDold=JSD) %>% select(sample1, sample2, JSDold)
    tcr_pairs_all <- tcr_raw_w_jsd  %>% rownames_to_column("raw_sample1") %>% 
      pivot_longer(cols=-raw_sample1, names_to="raw_sample2", values_to = "JSD") %>% 
      filter(grepl("Pt", raw_sample1) & grepl("Pt", raw_sample2))
    if (FALSE) write.csv(
      quote = FALSE,
      data.frame(new=unique(c(tcr_pairs_all$sample1, tcr_pairs_all$sample2)),
                 old=c(unique(c(orig_jsd$sample1, orig_jsd$sample2)), 
                       rep(NA, length(unique(tcr_pairs_all$sample1))- length(unique(orig_jsd$sample1))))), 
      file = "for_sample_name_key.csv")
    sample_key <- read.csv("sample_name_key.csv")
    tmp <- left_join(
      orig_jsd, 
      tcr_pairs_all%>% 
        left_join(sample_key, by=c("raw_sample1"="clean_names")) %>% 
        left_join(sample_key, by=c("raw_sample2"="clean_names")) %>% 
        rename(sample1=original_names.x, sample2=original_names.y) %>% 
        select(sample1, sample2, JSD), 
      by= c("sample1", "sample2")) %>%
      filter(!is.na(JSD)) %>%
      mutate(diff=JSD-JSDold)
    all.equal(tmp$JSDold, tmp$JSD)  
    #tmp %>%  arrange(desc(diff)) %>% write.csv("JSD_differences.csv", row.names = FALSE)
  }
  # Spearman calculations are not needed; see https://github.com/nickp60/DeWolf-GTEx-TCR/ if needed in future for some reason
  # tcr_corrs <- inner_join( jsd_tcr_pairs, combinations,  by=c("sample1"="x", "sample2"="y")) %>% 
  #  mutate(
  #     sample1_tissue=gsub(".*?_(.*)_.*", "\\1", sample1),
  #     sample2_tissue=gsub(".*?_(.*)_.*", "\\1", sample2),
  #     sample1_clean=gsub("(.*?)_(.*)_.*", "\\1", sample1),
  #     sample2_clean=gsub("(.*?)_(.*)_.*", "\\1", sample2)
  #   ) %>% rename(spearman=cor)
  # jsd_tcr_agg_individuals <- tcr_corrs %>% 
  #   select(sample1, sample2, JSD) %>% 
  #   pivot_wider(names_from="sample2", values_from="JSD") %>%
  #   column_to_rownames("sample1") %>%
  #   as.matrix()
  # spear_tcr_agg_individuals <- tcr_corrs %>% 
  #   select(sample1, sample2, spearman) %>% 
  #   pivot_wider(names_from="sample2", values_from="spearman") %>%
  #   column_to_rownames("sample1") %>%
  #   as.matrix()
  
  # jsd_tcr_agg_individuals<- jsd_tcr_agg_individuals[, rownames(jsd_tcr_agg_individuals)]
  # spear_tcr_agg_individuals<- spear_tcr_agg_individuals[, rownames(spear_tcr_agg_individuals)]
  # 
  tcr_sample_metadata <- tcr_raw %>% 
    select(sample_name, org,  samp_type, collection_day,  sample_amount_ng, indv_type, exp_rep, gvhd, indv_id, tissue) %>% 
    distinct()  %>%
    mutate( indv_label = paste(samp_type, indv_id),
            indv_label = ifelse(!is.na(exp_rep), paste0(indv_label, ", rep", exp_rep), indv_label ),
            indv_label = ifelse(!is.na(collection_day), paste0(indv_label, ", day ", collection_day), indv_label ),
            indv_tissue_label = paste(samp_type, indv_id, "-", gsub("_", " ", tissue))
            
    ) 
  # sample_patient_combos <-  sample_combinations %>% select(1:2) %>% 
  #   left_join(tcr_sample_metadata, by=c("sample1"="sample_name") ) %>%
  #   left_join(tcr_sample_metadata, by=c("sample2"="sample_name") ) %>%
  #   select(sample1, indv_label.x, sample2, indv_label.y) 
  #   #   right_join(tcr_raw_filt %>% select(sample_name, rearrangement), by=c("sample1"="sample_name"))
  # #   right_join(tcr_raw_filt %>% select(sample_name, rearrangement), by=c("sample2"="sample_name")) %>% 
  # #     group_by(indv_label.x)
  # registerDoParallel(6)
  # patient_combos %>% select(indv_label.x, indv_label.y) %>% distinct()
  # par_morisita <- foreach (i=1:nrow(patient_combos), .combine=rbind) %dopar% {
  #   
  #   horn_morisita(dt_tcr_w[sample_combinations$sample1[i], ], dt_tcr_w[sample_combinations$sample2[i], ]) 
  # }
  # colnames(par_morisita) <- "morisita"
  # rownames(par_morisita) <- NULL
  # 
  
  

  save(list = c( "tcr_sample_metadata", "tcr_corrs"), file = tcr_objects_path  )
  
} else{
  load(tcr_objects_path)
}

```


## Summary Tables
```{r}
tab_dir <- "tables"
dir.create(tab_dir, showWarnings = FALSE)

getslope <- function(vals){
  vals = vals[vals$Included == "Yes",]
  slope = coef(lm(log(vals$n)~log(vals$productive_frequency)))[[2]]
  sample_name = unique(vals$sample_name)
  return(cbind.data.frame(sample_name = sample_name, slope = slope))
}

slope_clean_low_frequency_clone<-function(vals)
{
  vals$Included = c("Yes")
  vals = vals[order(vals$n),]
  
  vals_1clone = vals[vals$n == 1,]
  ind = nrow(vals_1clone)
  
  if (nrow(vals_1clone) <= 1){
    return(vals)
  } else {
    bottom1 = vals_1clone$productive_frequency[1]
    bottom2 = vals_1clone$productive_frequency[2]
    
    if (abs(log(bottom1)-log(bottom2)) < 1.5) {
      cutoff_point = vals_1clone$productive_frequency[3]
      vals$Included[vals$productive_frequency > cutoff_point] = "No"
      vals$Included[3:ind] = "No"
      return(vals)
    } else {
      cutoff_point = vals_1clone$productive_frequency[2]
      vals$Included[vals$productive_frequency > cutoff_point] = "No"
      vals$Included[2:ind] = "No"
      return(vals)
    }
  }
} 
slopes <- tcr_raw %>% 
  filter(frame_type == 'In') %>%
  group_by(sample_name) %>%
  count(productive_frequency) %>% 
  #filter(n > sort(n)[2])
  group_split(.) %>% 
  map(~slope_clean_low_frequency_clone(.)) %>%
  map(~getslope(.)) %>% 
  do.call(rbind.data.frame,.)


(tab_sample_summary <- tcr_raw %>% 
    filter(frame_type == "In") %>% 
  group_by(sample_name, productive_templates, productive_rearrangements, sample_amount_ng, max_productive_frequency) %>% 
  summarize(
    entropy = -sum(log2(productive_frequency)*productive_frequency),
    len = n(), 
    clonality = 1- entropy/(log2(len))) %>% 
  left_join(slopes))
write.csv(tab_sample_summary, row.names = FALSE, file = file.path(tab_dir, "st4.csv"))



tcr_raw %>% 
    filter(frame_type == "In") %>% 
  group_by()
```



## Plot Trees of all Human transplant patients
The following code creates plots showing the high-level relationships between the profiles of all the samples.  We show 4 sets of data:

- `just_patients`:  These are the 7 patients A-G described in the paper, without the 3 comparator patients H-J.
- `all`: All human and mice samples
- `all_no_donor_mice`: Same as `all`, but without the mouse donor Tcells.
- `all_no_donor_no_healthy_control_mice`: Same as `all`, but without the mouse donor Tcells or the Balb-c healthy comparator mice.


```{r}
for (batch in c("just_patients", "all", "all_no_donor_mice", "all_no_donor_no_healthy_control_mice")){
  # batch="just_patients"
  if (batch == "just_patients"){
    these_samples <- tcr_sample_metadata %>% filter(org == "Human" & gvhd == "GvHD") 
  } else if (batch == "all"){
    these_samples <- tcr_sample_metadata
  } else if (batch == "all_no_donor_mice"){
    these_samples <- tcr_sample_metadata %>% filter(samp_type != "Donor")
  } else if (batch == "all_no_donor_no_healthy_control_mice"){
    these_samples <- tcr_sample_metadata %>% filter(samp_type != "Donor" & samp_type != "Healthy")
  }
  n_indv <- n_distinct(these_samples$indv_label)
  print(str_glue("making '{batch}' plots: {n_distinct(these_samples$sample_name)} samples from {n_indv} individuals"))
  for (metri in c("JSD")){
    this_corr_data <-  tcr_corrs %>% 
      filter(sample1 %in% these_samples$sample_name) %>% 
      filter(sample2 %in% these_samples$sample_name) %>% 
      select(sample1, sample2, all_of(metri))
    tcr_agg_individuals <- this_corr_data %>% 
      pivot_wider(names_from="sample2", values_from=all_of(metri)) %>%
      column_to_rownames("sample1") %>%
      as.matrix()
    
    
    dend_<- hclust(as.dist(tcr_agg_individuals), method = "single") %>% as.dendrogram()
    samples_ordered <- hclust(as.dist(tcr_agg_individuals), method = "single")$labels[c( hclust(as.dist(tcr_agg_individuals), method = "single")$order)]
  
  # get the clean, ordered sampleids
  samples_ordered_df <- left_join(data.frame(sample_name=samples_ordered), tcr_sample_metadata, by="sample_name")
  if (!all(samples_ordered == samples_ordered_df$sample_name)) {stop("Error assigning clean name to ordered tissues")}
  samples_ordered_clean <- samples_ordered_df %>% pull(indv_tissue_label)
  
  dendextend::labels_colors(dend_) <- data.frame(Tissue = labels(dend_)) %>%
    left_join(., tissue_key) %>% pull(col)
  
  
  
  tmp <- ape::as.phylo(dend_)
  tmp$edge.length <- tmp$edge.length*2
  tmpheight <- sort(stats::cophenetic(dend_), decreasing = TRUE)[1] 
  
  ugly_specific_tissue_key <- this_corr_data %>% 
    left_join(tcr_sample_metadata, by=c("sample1"="sample_name")) %>% 
    select(sample1, tissue, indv_label) %>% distinct() 
  
  tick_pos <- seq(0, 1, .1)
  ticks=data.frame(xorig=tick_pos, x=tick_pos - (1-tmpheight),
                   lab=rev(tick_pos),  yend=rep(.3, length(tick_pos))) 
  
  thesecolors=rep(RColorBrewer::brewer.pal(n = 12, name="Paired"), 4)[1:n_indv]
  names(thesecolors)  <- unique(ugly_specific_tissue_key$indv_label)
  
  p_tcr_all <- ggtree(tmp)  %<+% ugly_specific_tissue_key + xlim(-.05, 1.25) +
    geom_tiplab(aes(color=indv_label, label=tissue), 
                offset = 0.01,#(1-max(tmp$edge.length)) + .01, 
                align = FALSE, linetype = NA) +
    geom_tippoint() +
    scale_linetype(guide="none") +
    labs(color="Patient") +
    scale_color_manual(values=thesecolors, guide="none") +
    geom_segment(y=0, yend=0, x=min(ticks$x), xend=max(ticks$x)) + 
    annotate(geom="text",        x=ticks$x, y=-1, label=ticks$lab )   + 
    geom_segment(data=ticks, aes(y=-yend, yend=0, x=x, xend=x )) +
    theme(legend.position = c(.2, .95)) 
  
  # This nonsense adds the grouping label bars for the just_patients set.  Probably easier to just do in illustrator
  if (metri=="JSD" & batch == "just_patients"){
    p_tcr_all <-  p_tcr_all +
      geom_cladelab(node=94, label=names(thesecolors)[1], angle=270, align=F, geom='text', textcolor=thesecolors[1], offset=.2, vjust=-.1, barcolor = thesecolors[1]) +
      geom_cladelab(node=98, label=names(thesecolors)[2], angle=270, align=F, geom='text', textcolor=thesecolors[2], offset=.2, vjust=-.1, barcolor = thesecolors[2]) +
      geom_cladelab(node=91, label=names(thesecolors)[3], angle=270, align=F, geom='text', textcolor=thesecolors[3], offset=.2, vjust=-.1, barcolor = thesecolors[3]) +
      geom_cladelab(node=96, label=names(thesecolors)[4], angle=270, align=F, geom='text', textcolor=thesecolors[4], offset=.2, vjust=-.1, barcolor = thesecolors[4]) +
      geom_cladelab(node=97, label=names(thesecolors)[5], angle=270, align=F, geom='text', textcolor=thesecolors[5], offset=.2, vjust=-.1, barcolor = thesecolors[5]) +
      geom_cladelab(node=86, label=names(thesecolors)[6], angle=270, align=F, geom='text', textcolor=thesecolors[6], offset=.2, vjust=-.1, barcolor = thesecolors[6]) +
      geom_cladelab(node=89, label=names(thesecolors)[7], angle=270, align=F, geom='text', textcolor=thesecolors[7], offset=.2, vjust=-.1, barcolor = thesecolors[7]) 
  }
  ggsave(p_tcr_all, height = 2 + n_indv, width = 9, filename = file.path(figs_dir, str_glue("{metri}_TCR_{batch}_tree.pdf")))
  
  
  pmat_tcr_all<- ggplot(
    this_corr_data %>% 
      rename(thisfill=metri) %>% 
      mutate(
        sample1=factor(sample1, levels = samples_ordered, ordered = TRUE),
        sample2=factor(sample2, levels = samples_ordered, ordered = TRUE),
        lab = round(thisfill, 2),
      ), aes(x=sample1, y=sample2, fill=thisfill)) + 
    geom_tile() + 
    coord_fixed(ratio=1) + 
    geom_text(aes(label=lab), color="grey50", size=1)+
    scale_fill_viridis_c(option = "A") +
    guides(fill = guide_colourbar(direction = "horizontal")) + 
    scale_y_discrete(position = "right", expand = c(0,0), labels=samples_ordered_clean) +
    scale_x_discrete( expand = c(0,0), labels=samples_ordered_clean) +
    labs(subtitle=metri) +
    theme(axis.text.x = element_text(angle=315, hjust=0, size=9), legend.position = "bottom")
  
  ggsave(pmat_tcr_all, width = 5+n_indv , height = 5+n_indv, filename = file.path(figs_dir, str_glue("{metri}_TCR_{batch}_heatmap.pdf")))
}  
}

```



```{r}
objects_for_saving <- c(  
"jsd_tcr_agg_individuals",  
"p_tcr_all", 
"pmat_tcr_all",  
 "thesecolors")
for(ob in objects_for_saving){
  if (!ob %in% ls()){
    print(paste0("Warning: ", ob, " not in environment"))
    objects_for_saving <- objects_for_saving[objects_for_saving != ob]
  }
}
save(list = objects_for_saving, file = "tcr_graphic_objects.RData")
```
 
 
 ## Generate cross-patient tissue similarity plots for the GTEx transcription data

```{r}

for (metri in c("jsd")){
  tick_pos <- seq(0, 1, .1)
  if (metri == "jsd"){
    this_ob <- jsd_agg_dist_corr
    tmpheight <- sort(stats::cophenetic(this_ob[[1]]), decreasing = TRUE)[1] 
    ticks=data.frame(xorig=tick_pos, x=tick_pos - (1-tmpheight),
                     lab=rev(tick_pos),  yend=rep(.2, length(tick_pos)))  
    ticks <- ticks %>% filter(xorig >= min(1-this_ob[[2]]))
  } else {
    this_ob <- spear_agg_dist_corr
    tmpheight <- sort(stats::cophenetic(this_ob[[1]]), decreasing = TRUE)[1] 
    ticks=data.frame(xorig=tick_pos, x=tick_pos - (1-tmpheight),
                     lab=rev(tick_pos),  yend=rep(.2, length(tick_pos)))  
    ticks <- ticks %>% filter(xorig >= min(this_ob[[2]]))
  }
  tmp <- ape::as.phylo(this_ob[[1]])
  tmp$edge.length <- tmp$edge.length*2
  # need to do this in cases lacking single root
  
  
  tmp_anno <- data.frame(sample_name=rownames(this_ob[[2]])) %>% 
    mutate(
      patient = gsub("(.*?) - .*", "\\1", sample_name),
      tiss = gsub("(.*?) - (.*)", "\\2", sample_name),
    )
  (p <- ggtree(tmp)  %<+% tmp_anno  + xlim(min(ticks$x), max(ticks$x)*3) + 
      geom_tiplab(offset = 0.05,#(1-max(tmp$edge.length)) + .01, 
                  align = T, linetype = NA, size=3, 
      ) +
      geom_tippoint(position =position_nudge(x = 0.025), aes(color=patient, shape=tiss), size=3) +
      labs(title="GTEx",
           subtitle=str_glue("7 patients, distances based on {metri}")) + 
      scale_linetype(guide="none") + 
      scale_shape_manual(values=1:13)+
      scale_color_brewer(palette = "Paired") + 
      geom_segment(y=0, yend=0, x=min(ticks$x), xend=max(ticks$x)) + 
  #    geom_vline(xintercept = max(tmp$edge.length)) +
      theme(legend.position = c(.2, .6))+
      annotate(geom="text",        x=ticks$x, y=-.5, label=ticks$lab )   + 
      geom_segment(data=ticks, aes(y=-yend, yend=0, x=x, xend=x )) 
  )
  
  
  ggsave(
    p,
    width=8, height=18, file=file.path(figs_dir, str_glue("GTEx_samples_alltogether_{metri}.pdf"))
  )
}

```

